
/**
 * @fileoverview Firestore Security Rules for EcoCity application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model, where users can only
 * access their own profiles, addresses, rewards, and orders. It prioritizes
 * secure access over complex data validation in this prototyping phase.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data.
 * - /users/{userId}/addresses/{addressId}: Stores user addresses.
 * - /users/{userId}/rewards/{rewardId}: Stores user rewards.
 * - /users/{userId}/orders/{orderId}: Stores user orders.
 * - /leaderboard/{userId}: Stores public-facing leaderboard data.
 *
 * Key Security Decisions:
 * - Users can only perform CRUD operations on their own data in the /users collection.
 * - The /leaderboard collection is publicly readable but can only be written to by the user who owns the entry. This allows the game client to update the score.
 *
 * Denormalization for Authorization: N/A, the data model is already structured for owner-based authorization.
 * Structural Segregation: The `leaderboard` collection separates public game scores from private user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Users can read and write their own profile.
     * @path /users/{userId}
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Users should not be able to list all other users.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user addresses. Users can manage their own addresses.
     * @path /users/{userId}/addresses/{addressId}
     */
    match /users/{userId}/addresses/{addressId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow read, write: if isOwner(userId);
    }

    /**
     * @description Secure user rewards. Users can only access their own rewards.
     * @path /users/{userId}/rewards/{rewardId}
     */
    match /users/{userId}/rewards/{rewardId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow read, write: if isOwner(userId);
    }

    /**
     * @description Secure user orders. Users can only access their own orders.
     * @path /users/{userId}/orders/{orderId}
     */
    match /users/{userId}/orders/{orderId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Allow users to create, read, update, and delete their own orders.
      allow read, write: if isOwner(userId);
    }
    
    /**
     * @description Public leaderboard data. Anyone can read, but only the user can write their own score.
     * @path /leaderboard/{userId}
     */
    match /leaderboard/{userId} {
       allow read: if true; // The leaderboard is public
       allow write: if request.auth.uid == userId; // Only the user can write to their own leaderboard entry
    }
  }
}
